## 跟你朋友介紹 Git

### 脫離無止盡的最終版：基本的版本控制

『菜哥那你目前是怎麼紀錄笑話的』

「對阿，我的笑話有很多版本欸，有些甚至會到版本十，這樣每次修改一次笑話，我都要另存一個新的檔案欸。」

「還有還有，我還要準備另外一個筆記本寫說：
> - ver.2 原來指鹿為馬的部分這個有點牽強，所以修改一下。
> - ver.3 

都要記錄說自己每個版本修改了什麼，其實也是挺麻煩的，就不能直接用電腦記嗎？」

『可以啊，有甚麼問題，我現在就來教你神通廣大的 git 來拯救菜哥你。』

「真的嗎？如果最後我會了我就給你小歐的簽名照一張。無碼的ㄛ」

『等等，先不要，我完全沒有答應要這個，先不要從抽屜找照片。

你先下載 git 然後安裝，再打開 command line 然後進入你存放笑話的資料夾，

不會的話可以找 h0w，聽說他會。』

「我會啦，這種小事情不用麻煩我們團長 h0wger 齁。教給我大 GG 菜哥就好了。」

『再來，你可以輸入 `git init` 下面的指令，這是**讓你的資料夾開始可以使用 git 幫這個資料夾做版本控制的意思**，」

『輸入完之後，你可以用 `git status` 看看**目前版本控制的狀態**，你會發現說，上面有顯示說 untracked file，這代表說這些檔案目前沒有被進行版本控制。

因為版本控制是以資料夾為單位，就像你可能會把泱泱的電話還有你的笑話放在同一個資料夾，可是你並不需要對泱泱的電話做版本控制，只需要控制笑話的版本就好。』

「哈哈哈哈哈沒有啦，我跟泱泱只是朋友啦哈哈哈哈。」

『那接下來要選擇需要做版本控制的檔案，使用 `git add <檔案名稱>` ，**對檔案第一次使用這個指令，就可以開始追蹤檔案**

使用完之後，再使用 `git commmit -m <版本訊息>` ，這個`指令可以建立一個的版本`，

你還記得你之前都要用另存新檔的方式嗎？而且還要用筆記本另外記錄說每個版本到底改了甚麼。用 git 只要在指令後面輸入你每一個版本修改什麼，就可以自動和每一個版本綁定再一起了，是不是很棒。

，這樣我們就建立好一個笑話的 "初版" 了。

建立好之後你可以使用 `git log` 看看自己的第一個版本（看完，可以用 `q` 離開），還有用 `git status` 看看，一開始的 untracked file 就不見了。」

「原來這樣就完成了喔！我以為很難欸，工程師真的很厲害，不過我跟你說，我會擔心一件事情。我覺得你以後可能會被你家人罵」

『為什麼？當工程師不好嗎？』

「可是你當的是前端工程師阿，這樣會被比較傳統的人說你"觀前不顧後"欸，你要注意一點喔。」

『喔喔，原來是"前端"的部分啊。』

『再來你可以做一點修改，然後再看看 `git status`，會看到 `changes not staged got commit`，not staged 意思表示說："**你有做更改但是不知道你要不要把這個檔案的更動存成新的版本**"

那你可以重複一次剛剛 `git add <檔案名稱>` 的步驟。這樣就**代表準備被加入新版本，但是還沒建立**

最後再輸入 `git commit -m <版本訊息>` 就可以建立新版本了
』


『
再 git 中的檔案會有四個階段，如果清楚的話就可以知道每個指令到底在幹嘛。

1. untracked：連第一次的 add 都沒有，還沒開始追蹤 => 這時候對檔案使用第一次的 `git add <檔案名稱>` 就可以開始追蹤
2. unstaged ：已經有存過版本了，但是後來你有做更動，而且還沒被加入 **"準備區"** 。
3. staged ：你有做更動，而且 **"準備好"** 被存成新的版本 => 使用 `git commit -m <版本訊息>` ，就可以存成新的版本
4. new version (git 裡面好像沒有正式的名稱) => 如果再作改動，又會回到 unstaged 的狀態。
』


### 檔案的平行世界：branch & merge

「可是我還有一個問題，有時候我突然有靈感就會改腳本，但是前面的部分要先給廠商看欸，然後可能廠商也會要求說要修改，這樣我自己的靈感還有廠商的修改就會混在一起，很不方便欸。有沒有功能可以解決我這個問題啊。」

『那我覺得你可以使用 branch 的功能。 branch 就像以前玩神奇寶貝可以另外存一個存檔一樣﹐你可以一個存檔在有靈感的時候修改，然後另一個專門處理廠商的修改。

git 跟神奇寶貝最大的不同就是，**每一個分出去的存檔都可以在合併回去原本的存檔**，這個我們稱之為 merge。

簡單說，如果你有兩個存檔：主存檔、存檔A。

你可能在存檔 A 抓到超夢你可以把存檔 A 併回主存檔，那麼你的主存檔就會有 A 的超夢。』

![](https://i.imgur.com/SIh6wEj.png)

在 git 裡面，你可以用 `git branch <branch 名稱>` 來建立新的 branch，也就是我們剛剛講的新的存檔。

建立好之後，你可以用 `git checkout <branch 名稱>` 來切換存檔，進去那個存檔修改東西，並且在存檔 A 的 branch 中做出新的 commit 後，

切換到你的主存檔，在 git 中，主存檔預設稱作 master也就是 master ，所以切回主存檔就是 `git checkout master` 。

最後，我們要執行把其他 branch 併回來的動作。`git merge <要併進來的 branch 名稱>`，merge 的同時 git 就會自動幫你 commit。。
』

「可是這樣有一個問題欸：假如我的主存檔有一隻伊布，

我又開了另一個存檔 A，存檔 A 的伊布我它進化成水精靈，主存檔的伊布進化成火精靈。

如果我在把兩個存檔合併回主存檔的話同一支伊布會變甚麼？」

![](https://i.imgur.com/XDsGBz5.png)

『可能會變成薛丁格的伊布吧？不對。

如果在不同的的存檔進化到同一隻伊布 （不同的 branch 修改到同一個檔案）的情形。
那當然魚與熊掌不可兼得，不可能一隻變兩隻，所以你可能需要把其中一隻送去屠宰場或怎麼樣的，總之你必須解決兩個版本在同一支伊布進化的問題。

這樣在不同的 branch 上修改到同一個檔案的情形我們稱之為 "conflict"。

當你在 merge 時（就是剛剛講的合併存檔），因為修改到同一個檔案而產生 conflict 所以 merge 無法自動幫你 commit，你必須自己修改這些檔案。（訊息會告訴你有那些產生 conflict 的地方）

> ![](https://i.imgur.com/bSNSAyH.png)
> 
> git 會幫你把檔案中有衝突的部分列出來，並指出兩個 branch 的差異。
>
> ![](https://i.imgur.com/Exx5Xyu.png)
> 
> 必須修改這個檔案，修改過後再自己進行 commit 才算 merge 完成。
』

「很複雜欸，講到這裡你不覺得字數變很多嗎？能不能簡單地講一次你剛剛講的衝突？」

『簡單說，

merge 可以將不同 branch 的內容作合併，然後送出 commit

但是當你**不同 branch 的檔案之間有修改到相同的東西**，你就必須要

自行去處理這些檔案，最後再自己手動 commit 』

### 多人運動：github

「那我懂了...吧，這超複雜的。我還有最後一個問題。我後天要上勃恩YAYA秀，我跟勃恩他們要一起寫稿，那 git 可不可以做到我們大家一起用這個 git 的系統做版本控制？」

『...阿你不是上過了』

「不管啦，我們就是要多人運動，應該可以處理吧。」

『其實 git 也有類似我們平常使用的 goole drive 類似的應用，可以有一個平台大家把自己的存檔丟上去，或者是把雲端上的存檔下載下來。其中最有名的就是，世界上最大的男性交友平台 --- [github](https://github.com/)！！！

github 跟 google drive 這種雲端硬碟比較不同。雲端硬碟是有另一個線上的空間可以放自己的資料。但是 github 比較像有一個和你同步的 "分身" 儲存在網路上。

每次在自己的電腦做完東西時，就必須把**自己的存檔同步到網路上**，讓其他看到自己做了哪些東西。然後下次要做時，**再將其他人同步上來的存檔同步下來**。
』

『阿要用這個的話，你必須先辦理會員。接下來按右上角的 + 號新增一個 repository。

什麼是 repository 呢？還記得一開始我的做過的 `git init` 嗎？當初是說這個指令可以在資料夾開始使用 git。使用 Git 的這個資料夾就可以稱做 repository，簡稱 repo。這個 new repository 就是在 github 建立一個新的資料夾。

這個建立的資料夾有點像新增的遊戲紀錄一樣，是一張白紙甚麼都沒有的，當然 github 也有提供編輯的功能，ummm 但是大多只會拿來應急用，比較常見的做法是像剛剛講的 **"把自己的存檔同步到網路上"** 接下來就會使用這樣的做法。

首先你需要拿到一串網址：

![](https://i.imgur.com/NaHE4YF.png)

如果你的 repo 是剛建立的那就會直接看到。

接下來利用 command line tool 到你電腦裡面輸入下面的指令

> `git remote add origin <gitgub 的 url>`

這個指令比剛剛的都還長阿...但是其實並不複雜。

簡單說，就是**新增(add)**一個和自己**遠端同步(remote)**的 repo ，位置是 *<gitgub 的 url>(可以輸入自己的 url)*，代號 *origin(名稱其實也可以自己訂，但通常大家都用 origin)*。

概念相當於把 github 上的 repo 加進自己的常用地址，就像我們會講說 "h0w哥家"，但其實我們稱呼的 "h0w哥家" 其實確切地址是 "台北市信義區松勇路 110 號" 。

origin 就相當一個代稱，也就是上面的 "h0w 哥家"， github url 就像確切的地址 => "台北市信義區松山路 111 號"。 而 origin 這個名稱就會在之後需要指定 github 上的 repo 時用到。

加入地址了，接下來就是同步存檔了。在 github 裡面，同步是以 branch 為單位的，在第一次，我們要做的是把電腦中已經有的 repo ，推(push)到 github 上面。

> `git push -u origin master`

在 git 裡面，從電腦同步到線上的指令稱作 `push`，而從線上同步到電腦的指令稱作 `pull`，但是這個指令除了將自己的 master 同步到 github 上以外，也把**自己電腦的 master** 和 **origin （也就是 github 上的 repo） 的 master** 牽紅線。

經過上面的市定，如果之後 master 這個 branch 要 push 的話，就不需要再重新指定說 "我要同步到 origin 的 master"（對應的指令是 `git push origin master`） ，只要你現在在 master 直接輸入 `git push`，就可以同步到 github 對應的 master 囉。

上面講完了同步到線上，接下來最後一個步驟就是從線上同步到電腦了。

剛剛提到 從線上同步到電腦的指令稱作 `pull` （拉下來的感覺）。當你在在 master 這個 branch 中輸入 `git pull`，就可以把在線上其他人同步到 github 的版本 "merge" 下來。

要注意的是，`git pull` 相當於把位於 github 上的 branch merge 到自己的 branch ，只要是 merge 都有可能會遇到 conflict 的問題。所以如果遇到 conflict 就和 merge 其他 branch 相同的方式就可以解決。

終於講完拉，最後來個小小總複習吧

#### 開始使用 git
1. `git init`：將資料夾初始化，可以開始使用 git 囉。
2. `git add .`：將所有的檔案加入版本控制的行列(untracked => staged)
3. `git commit -m <版本訊息>`：建立第一次的版本

#### 儲存新的版本
1. `git add .`：把所有改過的檔案加入準備區(unstaged => staged)
2. `git commit -m <版本訊息>`：新增版本

#### 建立新的 branch （不同的存檔）
1. `git branch <branch 名稱>` ：建立新的 branch
2. `git checkout <branch 名稱>`：切換到 branch


#### merge branch （合併存檔）
1.  `git merge <branch 名稱>` ：把其他 branch 合併進來

如果有 comflict => 修改檔案內容後

2. `git commit -m <版本訊息>`：新增版本

#### 和遠端同步
第一次同步

1. `git remote add origin <url>`
2. `git push -u origin master`

- `git push`：設定好 `-u` 之後就可以直接同步到線上指定的 branch
- `git pull`：直接把線上的 branch merge 進來

#### 其他指令
- `git status`：看看自己 repo 內檔案版本控制的狀態
- `git log` ：看看過去的版本紀錄
``









